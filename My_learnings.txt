======================
Python Project Packaging & Development - Detailed Summary
======================

1. pyproject.toml
-----------------
- Purpose: Modern, standard configuration file for Python projects.
- Defines:
  1. Project metadata: name, version, description, authors.
  2. Dependencies: what external packages your project needs (can read from requirements.txt).
  3. Build system: which tool to use to build/install the package (usually setuptools).
  4. Tool configs: e.g., black, isort, mypy.
- Example:
  [project]
  name = "mypackage"
  version = "0.1"
  description = "My MLOps project"
  authors = [{name="Ankit", email="example@gmail.com"}]

  [tool.setuptools]
  packages = {find = {where=["src"]}}

  [tool.setuptools.dynamic]
  dependencies = {file="requirements.txt"}

- Key point: This is static and declarative, safer and easier for modern tools.

2. setup.py
-----------
- Purpose: Old way to define a package, dependencies, and build/install instructions.
- Why still used:
  - Backward compatibility with older tools and pipelines.
  - Can include dynamic logic (e.g., auto-generating versions or conditional dependencies).
- Minimal setup.py for modern projects:
  from setuptools import setup
  setup()  # Uses pyproject.toml automatically
- Comparison: .toml is modern and static; setup.py is legacy and dynamic.

3. Folder structure and packages
--------------------------------
- Package vs Module:
  - Folder with __init__.py â†’ package
  - Single .py file â†’ module
  - __init__.py inside a folder tells Python this folder is a package.
- Example:
  project/
  â”œâ”€â”€ src/                
  â”‚   â”œâ”€â”€ __init__.py
  â”‚   â”œâ”€â”€ module1.py      
  â”‚   â””â”€â”€ app.py          
  â”œâ”€â”€ pyproject.toml
  â”œâ”€â”€ setup.py
- Key point: Only folders with __init__.py are considered packages. Standalone files like app.py are modules inside that package.

4. find_packages() / packages={find={}}
--------------------------------------
- Purpose: Automatically discover all packages in your project.
- How it works:
  - Scans folders in the project directory.
  - Includes only folders with __init__.py as packages.
  - Automatically includes subpackages if they also have __init__.py.
- Standalone scripts or folders without __init__.py are ignored.
- Example:
  src/                  # included
  â”œâ”€â”€ __init__.py       # package
  â”œâ”€â”€ module1.py        # module
  â””â”€â”€ submodule/
      â”œâ”€â”€ __init__.py   # subpackage
      â””â”€â”€ module2.py    # module

5. -e . (editable install)
--------------------------
- Purpose: Install your local package in editable/development mode.
- What it does:
  1. Builds your project as a package.
  2. Creates a link from your Python environment to the local folder.
  3. Any changes in your source code (modules, classes, functions) are immediately available without reinstalling.
- Usage in requirements.txt:
  numpy>=1.25
  -e .
- Effect:
  - Makes your local package (src) importable anywhere in the same environment.
  - Live edits reflect immediately.
  - Ideal for development workflow.
- Without -e .:
  - Python may not see your local modules if your script (app.py) is outside the package folder.
  - Youâ€™d need to manually adjust sys.path or move files.

6. Why we need -e .
-------------------
1. Development convenience: No need to reinstall the package after every code change.
2. Importable modules anywhere in the environment:
   from src.module1 import MyClass
3. Keeps code organized: Treats src/ as a proper package; avoids messing with sys.path or relative imports.
4. Supports multiple projects in virtual environments: Each project can have its own editable package without conflicts.

7. Best practices
-----------------
- Use pyproject.toml for modern project metadata, dependencies, and build config.
- Keep setup.py minimal for backward compatibility.
- Use src/ as your package folder with __init__.py.
- Use -e . during development so changes are live and imports work anywhere in the environment.
- Use virtual environments to avoid conflicts when using common folder names like src.
- Give your package a unique name in pyproject.toml (can be different from src) to avoid import conflicts.

TL;DR (Super Simplified)
------------------------
File / Concept       | Purpose
--------------------|-------------------------------------------------------
pyproject.toml       | Modern, static config: metadata, dependencies, build system
setup.py             | Old, dynamic config: legacy builds, backward compatibility
src/                 | Package folder containing modules and classes
find_packages()      | Automatically detects folders with __init__.py to include as packages
-e .                 | Install local package editable, live code updates, importable anywhere
============================
ðŸ“Œ Python Logging - Detailed Notes
============================

1. Default Logging Behavior
---------------------------
- `import logging` alone â†’ uses ROOT LOGGER by default
- Level: WARNING+
- Output: terminal only
- No file handlers or formatting
- Example:
    import logging
    logging.info("Hello")  # Will not show by default

- âœ… Key observation:
  1. Simple logging outputs only to **terminal** if not configured
  2. Logs to **files, formatted messages, and rotations** happen **only after configuration**

---

2. Configuring Logging
----------------------
- Use a function to configure logging (handlers, formatters, levels)
- Common setup:
    - ROOT LOGGER
    - RotatingFileHandler (log files)
    - ConsoleHandler (terminal)
    - Formatter (timestamps, module, level)
- Example:
    import logging
    from logging.handlers import RotatingFileHandler

    def configure_logger():
        logger = logging.getLogger()  # ROOT LOGGER
        logger.setLevel(logging.DEBUG)

        formatter = logging.Formatter("[%(asctime)s] %(name)s - %(levelname)s - %(message)s")

        # File handler
        file_handler = RotatingFileHandler("logs/app.log", maxBytes=5*1024*1024, backupCount=3)
        file_handler.setFormatter(formatter)
        file_handler.setLevel(logging.DEBUG)

        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        console_handler.setLevel(logging.INFO)

        logger.addHandler(file_handler)
        logger.addHandler(console_handler)

- âœ… Key point:
  - Must configure logging **before logging messages** for files, formatting, rotation
  - If configuration is in a module, that module must be imported so code runs

---

3. Using Logging Across Modules
-------------------------------
- Configure logging **once in the entry-point** (e.g., main.py)
    from src.logger import configure_logger
    configure_logger()

- In any other module:
    import logging
    logger = logging.getLogger(__name__)
    logger.info("Message")
- Do **not** reconfigure in every module
- âœ… Key point:
  - Once configured, logging is **globally accessible**, no need to import logger file everywhere

---

4. How Imports Affect Logging
-----------------------------
- Importing a module executes **top-level code once**
- Functions/classes in the module **do NOT run automatically**
- Top-level `configure_logger()` in a module runs automatically on import
- Best practice: call `configure_logger()` explicitly in entry-point

---

5. Logging and Exceptions
-------------------------
- Custom exceptions can log errors:
    import logging

    class MyException(Exception):
        def __init__(self, msg):
            super().__init__(msg)
            logging.error(f"Error occurred: {msg}")

- Logging in exceptions **works only if logging is configured first**

---

6. Your Key Observations / Rules
---------------------------------
1. Simple logging outputs **only to terminal** if not configured
2. To log to files or have formatted messages, logging **must be configured**
3. Once logging is configured, it is **globally accessible** â€” you do not need to import the logger file in every module
4. If configuration is in a module, the module **must be imported** for configuration code to run

---

7. Key Takeaways
----------------
âœ… Configure logging **once**, in entry-point  
âœ… Use `logging.getLogger(__name__)` in all modules  
âœ… Do **not** call `configure_logger()` everywhere  
âœ… Importing logging does **not** create files  
âœ… Top-level code in modules executes on import, functions run only when called
